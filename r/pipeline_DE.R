library(edgeR)
library(ggplot2)
library(DESeq)
library(NOISeq)
library(vsn)
library(gplots)






args <- commandArgs(TRUE)
matfile<- args[1]   #matrix
groups_str<- args[2]  #groups
outdir<- args[3]  
pvalue<- as.numeric(args[4])
probNoiseq<- as.numeric(args[5])
basename<- args[6]
perc<-as.numeric(args[7])
min_t<-as.numeric(args[8])
groups<-unlist(strsplit(groups_str,",") )

#test_table<-read.delim("/media/sf_Mic_VM/sRNAde_matrix_mature_sense.mat")
#test_read<-read.table("/media/sf_Mic_VM/sRNAde_matrix_mature_sense.mat")
#stop("exit")

#Rscript /opt/sRNAtoolboxDB//r/pipeline_DE.R
# /home/srna/results/diffExpr_libs_genome//mature_sense_5_2.mat 
#nasopharyngitis,nasopharyngitis,nasopharyngitis,nasopharyngitis,carcinoma,carcinoma,carcinoma,carcinoma 
#/home/srna/results/diffExpr_libs_genome 
#0.05 
#0.8 
#mature_sense_5_2 
#1.0 
#50

#Rscript /opt/sRNAtoolboxDB//r/pipeline_DE.R /home/srna/results/diffExpr_libs_genome//mature_sense_5_2.mat nasopharyngitis,nasopharyngitis,nasopharyngitis,nasopharyngitis,carcinoma,carcinoma,carcinoma,carcinoma /home/srna/results/diffExpr_libs_genome 0.05 0.8 mature_sense_5_2 1.0 50

if (is.element("xlsx", installed.packages()[,1])){
  library(xlsx) 
  xls_output <- TRUE
}else{
  xls_output <- FALSE
}


group <- groups
sampletypevalues <- group[!duplicated(group)]

for(i in 1:(length(sampletypevalues)-1)) {
    for(j in (i+1):length(sampletypevalues)){
      xlsfile = paste(outdir,"/",basename,"_",sampletypevalues[i],"_vs_",sampletypevalues[j],".xlsx",sep="")
      print(xlsfile)
      
      if (file.exists(xlsfile)) file.remove(xlsfile)
      
}}


runedger <- function(datafile, sampletypes, dirout, pvalue, basename) {
  x <- read.delim(datafile,row.names="name")
  group <- sampletypes
  y <- DGEList(counts=x,group=group)
  y <- calcNormFactors(y)
  y <- estimateCommonDisp(y)
  y <- estimateTagwiseDisp(y)
  selected <- NULL
  sampletypevalues <- group[!duplicated(group)]
  
  
  for(i in 1:(length(sampletypevalues)-1)) {
    for(j in (i+1):length(sampletypevalues)){
      et <- exactTest(y, pair=c(sampletypevalues[i],sampletypevalues[j]))
      print(paste("testing gruops: ",sampletypevalues[i], " and ", sampletypevalues[j]))
      tt <- topTags(et, n=Inf)
      
      selected_samples <- (which(group==sampletypevalues[i] | group==sampletypevalues[j]))
      z<-as.data.frame(y$pseudo.counts)[,selected_samples]
      t<-as.data.frame(tt)
      data <- merge(z,t,by="row.names")
      row.names(data)<-data$Row.names
      data$Row.names<-NULL
      selected <- which(data$FDR<=pvalue)
      result<- data[selected,]
      
      #heatmap(cpm(x[selected,]))
      
           
      
      write.table(result, paste(dirout,"/",basename,"edgeR_table.csv",sep=""), sep="\t", row.names = TRUE)
      xlsfile = paste(dirout,"/",basename,"_",sampletypevalues[i],"_vs_",sampletypevalues[j],".xlsx",sep="")
      print(xlsfile)
      print("Writing DE genes...") 
      if (nrow(result) > 1){
        if(file.exists(xlsfile)) {
          write.xlsx(result, file=xlsfile, sheetName="Selection_edgeR", row.names=TRUE, append=TRUE)
        } else {
          write.xlsx(result, file=xlsfile, sheetName="Selection_edgeR", row.names=TRUE)
        }
      } 
      
      
      
      print("Writing full list of genes...")
      if((length(colnames(data))*length(rownames(data)))<394256) {
        write.xlsx(data, file=xlsfile, sheetName="Full_table_edgeR", row.names=TRUE, append=TRUE)
      } else {
        print(paste(c("The full table is too big to be written in an xlsx, writing as",dirout,"/",basename,"_edgeR.tsv"),sep=""))
        write.table(data, file=paste(dirout,"/",basename,"_edgeR.tsv",sep=""),col.names=TRUE,row.names=TRUE,quote=FALSE, sep="\t")
      }

      print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Finished <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
      
    }
  }
}


rundeseq <- function(datafile, sampletypes, threshold, dirout, pvalue, basename) {
  #**********************************************************************************************************************************************************************************
  #Task: runs DESeq
  #Inputs:
  #  files: list of strings, each containing the full path to a counts file as generated by htseq-count
  #	sampletypes: list of strings, each containing the sample type corresponding to the file in "files" at that position
  #	threshold: float value, indicating the expression threshold to use for removing low expressed genes
  #	dirout: string containing the path to the directory where results will be saved
  #Outputs: a file named dirout/de.xlsx will be created containing a DE data table. In addition, several graphs will be created: 
  #	- dirout/meansd.png: compares mean expression and standard deviation for each gene
  #	- dirout/dispersion.png: shows the fitting curve that corrects dispersion as a function of mean expression
  #	- dirout/ma.png: M vs. A plot in which DE genes are colored in red.
  #**********************************************************************************************************************************************************************************
  
	full<-read.delim(datafile,header=TRUE,row.names=1)
	  
	#full<-read.table( datafile, header=TRUE, row.names=1, fill=TRUE )
  #full<-read.table( datafile, header=TRUE, row.names=1 )
	
  print(dirout)
  print("Creating meta data...")
	print(sampletypes)
  print("start")
	#a <- readLines("stdin",n=1);
  condition = factor(sampletypes)
	print(condition)
	#a <- readLines("stdin",n=1);
  print("readLines")
  cds = newCountDataSet(full, condition)
  print("cds")
  cds = estimateSizeFactors(cds)
  
  print("Normalizing...")
  norvalues= counts(cds, normalized=TRUE)
  meanexpression <- rowMeans(norvalues)
  
  print("Creating filtered meta data...")
  rcounts = counts(cds)
  rcounts <- rcounts[which(meanexpression>=threshold),]
  filtered_cds = newCountDataSet(rcounts, condition)
  sizeFactors(filtered_cds) <- sizeFactors(cds)
  
  
  
  
  print("Estimating dispersion...")
  # Check whether there are replicates for the two sample types
  if(sum(duplicated(sampletypes))<2){
    filtered_cds = estimateDispersions(filtered_cds, method='blind', sharingMode="fit-only",fitType="local")
  }else{
    filtered_cds = estimateDispersions(filtered_cds,fitType="local")
  }
  
  print("Plotting dispersion...")
  png(paste(dirout,"/",basename,"_dispersion.png",sep=""), units='px', height=900, width=1600, res=90)
  plotDispEsts(filtered_cds)
  dev.off()
  
  print("Plotting mean stdv...")
  png(paste(dirout,"/",basename,"_meansd.png",sep=""), units='px', height=900, width=1600, res=90)
  meanSdPlot(log2(counts(filtered_cds, normalized=TRUE) + 1))
  dev.off()
  
  print("Normalizing...")
  ncounts <- counts(filtered_cds, normalized=TRUE)
  group<-sampletypes
  sampletypevalues <- sampletypes[!duplicated(sampletypes)]
  selected <- NULL

  for (i in 1:(length(sampletypevalues)-1)) {
      for(j in (i+1):length(sampletypevalues)) {
      print(paste("Testing",sampletypevalues[i],"vs.",sampletypevalues[j]))
      curresult = nbinomTest(filtered_cds, sampletypevalues[i],sampletypevalues[j])
      
      if(sum(is.na(curresult))>0){
        print("WARNING: NA values appear in DESeq result, probably due to 0 counts in both samples")
        print("    Rows with NA values will be ignored")
       # print(curresult[which(rowSums(is.na(curresult))>0),])
      }      
#       selected_samples <- (which(group==sampletypevalues[i] | group==sampletypevalues[j]))
#       
#       selected <- curresult$id[(abs(curresult$log2FoldChange)>=1) & (curresult$padj<=pvalue)]
#       
#       ncounts_selected <- cbind(ncounts[,selected_samples],curresult$foldChange, curresult$log2FoldChange, curresult$pval, curresult$padj)
#       colnames(ncounts_selected) <- c(head(colnames(ncounts_selected),n=-4),"foldChange","log2FoldChange","pval","padj")
#       ncounts_selected <- as.data.frame(na.omit(ncounts_selected))
#       result <- ncounts_selected[(abs(ncounts_selected$log2FoldChange)>=1) & (ncounts_selected$padj<=pvalue),]
      
      
      selected_samples <- (which(group==sampletypevalues[i] | group==sampletypevalues[j]))
      
      
      selected <- curresult$id[(abs(curresult$log2FoldChange)>=1) & (curresult$padj<=pvalue)]
      selected <- na.omit(selected)  
      ncounts_selected <- cbind(ncounts[, selected_samples],curresult$foldChange, curresult$log2FoldChange, curresult$pval, curresult$padj)
      colnames(ncounts_selected) <- c(head(colnames(ncounts_selected),n=-4),"foldChange","log2FoldChange","pval","padj")
      result <- ncounts_selected[selected,]
      
      
      
      
      
      png(paste(dirout,"/",basename,"_ma.png",sep=""), units='px', height=900, width=1600, res=90)
      plotMA(curresult)
      dev.off()
      
      
      xlsfile = paste(dirout,"/",basename,"_",sampletypevalues[i],"_vs_",sampletypevalues[j],".xlsx",sep="")
      print(xlsfile)
      print("Writing DE genes...") 
      if (length(selected) > 1){
        #result <- ncounts_selected[selected,]
        if(file.exists(xlsfile)) {
          write.xlsx(result, file=xlsfile, sheetName="Selection_deSeq", row.names=TRUE, append=TRUE)
        } else {
          write.xlsx(result, file=xlsfile, sheetName="Selection_deSeq", row.names=TRUE)
        }
      } 
      
      
      print("Writing full list of genes...")
      if((length(colnames(ncounts_selected))*length(rownames(ncounts_selected)))<394256) {
        write.xlsx(ncounts_selected, file=xlsfile, sheetName="Full_table_deSeq", row.names=TRUE, append=TRUE)
      } else {
        print(paste(c("The full table is too big to be written in an xlsx, writing as",dirout,"/",basename,"_deSeq.tsv"),sep=""))
        write.table(ncounts_selected, file=paste(dirout,"/",basename,"_deSeq.tsv",sep=""),col.names=TRUE,row.names=TRUE,quote=FALSE, sep="\t")
      }
      
   
    }
  }
  
  
  print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Finished <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
  
}



runnoiseq <- function(datafile, sampletypes, threshold, dirout, pvalue, basename) {
  #**********************************************************************************************************************************************************************************
  #Task: runs NOISeq
  #Inputs:
  #	files: list of strings, each containing the full path to a counts file as generated by htseq-count
  #	sampletypes: list of strings, each containing the sample type corresponding to the file in "files" at that position
  #	threshold: float value, indicating the expression threshold to use for removing low expressed genes
  #	dirout: string containing the path to the directory where results will be saved
  #Outputs: a file named dirout/de.xlsx will be created containing a DE data table. In addition, a graph will be saved named dirout/de.png which shows gene expression correlation
  #	between both samples and colours DE genes.
  #**********************************************************************************************************************************************************************************
  

    
	#  full<-read.table( datafile, header=TRUE, row.names=1 )
  full<-read.delim(datafile,header=TRUE,row.names=1)
  
  print("Creating meta data...")
  samplefactors <- data.frame(Sampletype=sampletypes)
  biotypes <- rep("transcript", dim(full)[1])
  names(biotypes) <- rownames(full)
  countdata <- readData(data = full, factors = samplefactors, biotype=biotypes)
  group<-sampletypes
  
  print("Normalizing...")
  TMMvalues <- tmm(assayData(countdata)$exprs,long=1000,lc=1)
  write.table(TMMvalues, file=paste(dirout,"/",basename,"_TMM_normalized.tsv",sep=""),col.names=TRUE,row.names=TRUE,quote=FALSE, sep="\t")
  meanexpression <- rowMeans(TMMvalues)
  
  TMMvalues <- TMMvalues[which(meanexpression>=threshold),]
  
  
  sampletypevalues <- sampletypes[!duplicated(sampletypes)]
  selected <- NULL
  #print("loop")
  for(i in 1:(length(sampletypevalues)-1)) {
    for(j in (i+1):length(sampletypevalues)){      
      print(paste("Testing",sampletypevalues[i],"vs.",sampletypevalues[j]))
      print("Creating meta data...")
      currcomparison <- which(sampletypes==sampletypevalues[i] | sampletypes==sampletypevalues[j])
      samplefactors <- data.frame(Sampletype=sampletypes[currcomparison])
      countdata <- readData(data = TMMvalues[,currcomparison], factors = samplefactors)
      cond <- levels(factor(samplefactors$Sampletype))
      print(cond)
      #curresult <- noiseq(countdata,norm="tmm",factor="Sampletype", conditions = cond )@results[[1]]
      print(countdata)
      print("good")  
      noiseq(countdata,norm="tmm",factor="Sampletype", conditions = cond )  

            
      if(sum(is.na(curresult))>0){
        print("WARNING: NA values appear in NOISeq result, probably due to 0 counts in both samples")
        print("    Rows with NA values will be ignored")
        #print(curresult[which(rowSums(is.na(curresult))>0),])
      }      
      
      selected_samples <- (which(group==sampletypevalues[i] | group==sampletypevalues[j]))
      
      
      selected <- rownames(curresult)[(abs(curresult$M)>=1) & (curresult$prob>=pvalue)]
      selected <- na.omit(selected)  
      TMMvalues_selected <- cbind(TMMvalues[, selected_samples],curresult$M, curresult$D, curresult$pval, curresult$prob)
      colnames(TMMvalues_selected) <- c(head(colnames(TMMvalues_selected),n=-3),"M","D","prob")
      result <- TMMvalues_selected[selected,]
      
      
      
      
      xlsfile = paste(dirout,"/",basename,"_",sampletypevalues[i],"_vs_",sampletypevalues[j],".xlsx",sep="")
      print(xlsfile)
      
      print("Writing DE genes...")  
      if (length(selected) > 1){
        if(file.exists(xlsfile)) {
          write.xlsx(result, file=xlsfile, sheetName="Selection_NOISeq", row.names=TRUE, append=TRUE)
        } else {
          write.xlsx(result, file=xlsfile, sheetName="Selection_NOISeq", row.names=TRUE)
        }
      } 
      
      
      print("Writing full list of genes...")
      if((length(colnames(TMMvalues_selected))*length(rownames(TMMvalues_selected)))<394256) {
        write.xlsx(TMMvalues_selected, file=xlsfile, sheetName="Full_table_NOISeq", row.names=TRUE, append=TRUE)
      } else {
        print(paste(c("The full table is too big to be written in an xlsx, writing as",dirout,"/",basename,"_NOISeq.tsv"),sep=""))
        write.table(TMMvalues_selected, file=paste(dirout,"/",basename,"_NOISeq.tsv",sep=""),col.names=TRUE,row.names=TRUE,quote=FALSE, sep="\t")
      }
      
    
    
    }
  }
  
  
  
 
  
  

  print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Finished <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<")
  
  
}


top_heatmap <- function(matfile, perc, min_t, dirout,basename) {
  #full<-read.table( matfile, header=TRUE, row.names=1 )
  full<-read.delim(matfile,header=TRUE,row.names=1)
  meanexpression <- rowMeans(full)
  
  if (dim(full[which(meanexpression>= quantile(meanexpression,perc)),])[1]<min_t){
    perc<-1-(min_t/length(meanexpression))
    print(perc)
  }
  
  top_selected <- full[which(meanexpression>= quantile(meanexpression,perc)),]
  
  my_palette <- colorRampPalette(c("red", "white", "blue"))(n = 299)
  png(paste(dirout,"/",basename,"_heatmap_perc",round(perc,2),".png",sep=""), units='px', height=900, width=1600, res=90)
  heatmap.2(cpm(top_selected, prior.count=2, log=TRUE),col=my_palette, density.info="none", trace="none",key=T, margins=c(12,20), keysize=0.7)
  dev.off()
  
  
  cpms<-cpm(top_selected)
  full_transform<-log2((cpms+2)/(apply(cpms,1,median) + 2 ))
  
  my_palette <- colorRampPalette(c("red", "white", "blue"))(n = 299)
  png(paste(dirout,"/",basename,"_heatmap_perc",round(perc,2),"_median_normalized.png",sep=""), units='px', height=900, width=1600, res=90)
  heatmap.2(full_transform,col=my_palette, density.info="none", trace="none",key=T, margins=c(12,20), keysize=0.7)
  dev.off()
}




#Call expample
#args<-c("/home/antonior/7079710/mature_sense_1_2.mat","normal,normal,Tumor,Tumor","/home/antonior/7079710/","0.05","0.8","name","0.9","20")

args <- commandArgs(TRUE)
matfile<- args[1]  	#matrix
groups_str<- args[2]	#groups
outdir<- args[3]	
pvalue<- as.numeric(args[4])
probNoiseq<- as.numeric(args[5])
basename<- args[6]
perc<-as.numeric(args[7])
min_t<-as.numeric(args[8])
groups<-unlist(strsplit(groups_str,",") )

zz <- file(paste0(outdir,"pipeline_DE.log"), open="at")
sink(zz, type="message")
write("DESeq", stderr())
try(rundeseq(matfile,groups,0,outdir,pvalue, basename))
print("DONE DEseq")

write("EdgeR", stderr())
try(runedger(matfile,groups,outdir,pvalue, basename))
print("DONE edgeR")

write("Noiseq", stderr())
try(runnoiseq(matfile,groups,0,outdir,probNoiseq, basename))
print("DONE Noiseq")

write("heatmap", stderr())
try(top_heatmap(matfile,perc, min_t, outdir, basename))
print("DONE heatmap")


